import { window } from "./browser";
export function toArray(nodes) {
    // const el = Array.prototype.slice.call(nodes);
    // for IE8
    var el = [];
    for (var i = 0, len = nodes.length; i < len; i++) {
        el.push(nodes[i]);
    }
    return el;
}
export function $(param, multi) {
    if (multi === void 0) { multi = false; }
    var el;
    if (typeof param === "string") { // String (HTML, Selector)
        // check if string is HTML tag format
        var match = param.match(/^<([a-z]+)\s*([^>]*)>/);
        // creating element
        if (match) { // HTML
            var dummy = document.createElement("div");
            dummy.innerHTML = param;
            el = toArray(dummy.childNodes);
        }
        else { // Selector
            el = toArray(document.querySelectorAll(param));
        }
        if (!multi) {
            el = el.length >= 1 ? el[0] : undefined;
        }
    }
    else if (param === window) { // window
        el = param;
    }
    else if (param.nodeName &&
        (param.nodeType === 1 || param.nodeType === 9)) { // HTMLElement, Document
        el = param;
    }
    else if (("jQuery" in window && param instanceof jQuery) ||
        param.constructor.prototype.jquery) { // jQuery
        el = multi ? param.toArray() : param.get(0);
    }
    else if (Array.isArray(param)) {
        el = param.map(function (v) { return $(v); });
        if (!multi) {
            el = el.length >= 1 ? el[0] : undefined;
        }
    }
    return el;
}
var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
var caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;
if (raf && !caf) {
    var keyInfo_1 = {};
    var oldraf_1 = raf;
    raf = function (callback) {
        function wrapCallback(timestamp) {
            if (keyInfo_1[key]) {
                callback(timestamp);
            }
        }
        var key = oldraf_1(wrapCallback);
        keyInfo_1[key] = true;
        return key;
    };
    caf = function (key) {
        delete keyInfo_1[key];
    };
}
else if (!(raf && caf)) {
    raf = function (callback) {
        return window.setTimeout(function () {
            callback(window.performance && window.performance.now && window.performance.now() || new Date().getTime());
        }, 16);
    };
    caf = window.clearTimeout;
}
/**
 * A polyfill for the window.requestAnimationFrame() method.
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
 * @private
 */
export function requestAnimationFrame(fp) {
    return raf(fp);
}
/**
* A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.
* @param {Number} key −	The ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>
* @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
* @private
*/
export function cancelAnimationFrame(key) {
    caf(key);
}
export function map(obj, callback) {
    var tranformed = {};
    for (var k in obj) {
        k && (tranformed[k] = callback(obj[k], k));
    }
    return tranformed;
}
export function filter(obj, callback) {
    var filtered = {};
    for (var k in obj) {
        k && callback(obj[k], k) && (filtered[k] = obj[k]);
    }
    return filtered;
}
export function every(obj, callback) {
    for (var k in obj) {
        if (k && !callback(obj[k], k)) {
            return false;
        }
    }
    return true;
}
export function equal(target, base) {
    return every(target, function (v, k) { return v === base[k]; });
}
var roundNumFunc = {};
export function roundNumber(num, roundUnit) {
    // Cache for performance
    if (!roundNumFunc[roundUnit]) {
        roundNumFunc[roundUnit] = getRoundFunc(roundUnit);
    }
    return roundNumFunc[roundUnit](num);
}
export function roundNumbers(num, roundUnit) {
    if (!num || !roundUnit) {
        return num;
    }
    var isNumber = typeof roundUnit === "number";
    return map(num, function (value, key) { return roundNumber(value, isNumber ? roundUnit : roundUnit[key]); });
}
export function getDecimalPlace(val) {
    if (!isFinite(val)) {
        return 0;
    }
    var v = (val + "");
    if (v.indexOf("e") >= 0) {
        // Exponential Format
        // 1e-10, 1e-12
        var p = 0;
        var e = 1;
        while (Math.round(val * e) / e !== val) {
            e *= 10;
            p++;
        }
        return p;
    }
    // In general, following has performance benefit.
    // https://jsperf.com/precision-calculation
    return v.indexOf(".") >= 0 ? (v.length - v.indexOf(".") - 1) : 0;
}
export function inversePow(n) {
    // replace Math.pow(10, -n) to solve floating point issue.
    // eg. Math.pow(10, -4) => 0.00009999999999999999
    return 1 / Math.pow(10, n);
}
export function getRoundFunc(v) {
    var p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;
    return function (n) {
        if (v === 0) {
            return 0;
        }
        return Math.round(Math.round(n / v) * v * p) / p;
    };
}
//# sourceMappingURL=utils.js.map