var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { getInsidePosition, isCircularable, getCirculatedPos, getDuration } from "./Coordinate";
import { requestAnimationFrame, cancelAnimationFrame, map, every, filter, equal, roundNumber, getDecimalPlace, inversePow } from "./utils";
function minMax(value, min, max) {
    return Math.max(Math.min(value, max), min);
}
var AnimationManager = /** @class */ (function () {
    function AnimationManager(_a) {
        var options = _a.options, itm = _a.itm, em = _a.em, axm = _a.axm;
        this.options = options;
        this.itm = itm;
        this.em = em;
        this.axm = axm;
        this.animationEnd = this.animationEnd.bind(this);
    }
    AnimationManager.prototype.getDuration = function (depaPos, destPos, wishDuration) {
        var _this = this;
        var duration;
        if (typeof wishDuration !== "undefined") {
            duration = wishDuration;
        }
        else {
            var durations_1 = map(destPos, function (v, k) { return getDuration(Math.abs(v - depaPos[k]), _this.options.deceleration); });
            duration = Object.keys(durations_1).reduce(function (max, v) { return Math.max(max, durations_1[v]); }, -Infinity);
        }
        return minMax(duration, this.options.minimumDuration, this.options.maximumDuration);
    };
    AnimationManager.prototype.createAnimationParam = function (pos, duration, option) {
        var depaPos = this.axm.get();
        var destPos = pos;
        var inputEvent = option && option.event || null;
        return {
            depaPos: depaPos,
            destPos: destPos,
            duration: minMax(duration, this.options.minimumDuration, this.options.maximumDuration),
            delta: this.axm.getDelta(depaPos, destPos),
            inputEvent: inputEvent,
            input: option && option.input || null,
            isTrusted: !!inputEvent,
            done: this.animationEnd,
        };
    };
    AnimationManager.prototype.grab = function (axes, option) {
        if (this._animateParam && axes.length) {
            var orgPos_1 = this.axm.get(axes);
            var pos = this.axm.map(orgPos_1, function (v, opt) { return getCirculatedPos(v, opt.range, opt.circular); });
            if (!every(pos, function (v, k) { return orgPos_1[k] === v; })) {
                this.em.triggerChange(pos, false, orgPos_1, option, !!option);
            }
            this._animateParam = null;
            this._raf && cancelAnimationFrame(this._raf);
            this._raf = null;
            this.em.triggerAnimationEnd(!!(option && option.event));
        }
    };
    AnimationManager.prototype.getEventInfo = function () {
        if (this._animateParam && this._animateParam.input && this._animateParam.inputEvent) {
            return {
                input: this._animateParam.input,
                event: this._animateParam.inputEvent,
            };
        }
        else {
            return null;
        }
    };
    AnimationManager.prototype.restore = function (option) {
        var pos = this.axm.get();
        var destPos = this.axm.map(pos, function (v, opt) { return Math.min(opt.range[1], Math.max(opt.range[0], v)); });
        this.animateTo(destPos, this.getDuration(pos, destPos), option);
    };
    AnimationManager.prototype.animationEnd = function () {
        var beforeParam = this.getEventInfo();
        this._animateParam = null;
        // for Circular
        var circularTargets = this.axm.filter(this.axm.get(), function (v, opt) { return isCircularable(v, opt.range, opt.circular); });
        Object.keys(circularTargets).length > 0 && this.setTo(this.axm.map(circularTargets, function (v, opt) { return getCirculatedPos(v, opt.range, opt.circular); }));
        this.itm.setInterrupt(false);
        this.em.triggerAnimationEnd(!!beforeParam);
        if (this.axm.isOutside()) {
            this.restore(beforeParam);
        }
        else {
            this.finish(!!beforeParam);
        }
    };
    AnimationManager.prototype.finish = function (isTrusted) {
        this._animateParam = null;
        this.itm.setInterrupt(false);
        this.em.triggerFinish(isTrusted);
    };
    AnimationManager.prototype.animateLoop = function (param, complete) {
        if (param.duration) {
            this._animateParam = __assign({}, param);
            var info_1 = this._animateParam;
            var self_1 = this;
            var destPos_1 = info_1.destPos;
            var prevPos_1 = info_1.depaPos;
            var prevEasingPer_1 = 0;
            var directions_1 = map(prevPos_1, function (value, key) {
                return value <= destPos_1[key] ? 1 : -1;
            });
            var originalIntendedPos_1 = map(destPos_1, function (v) { return v; });
            var prevTime_1 = new Date().getTime();
            info_1.startTime = prevTime_1;
            (function loop() {
                self_1._raf = null;
                var currentTime = new Date().getTime();
                var ratio = (currentTime - info_1.startTime) / param.duration;
                var easingPer = self_1.easing(ratio);
                var toPos = self_1.axm.map(prevPos_1, function (pos, options, key) {
                    var nextPos = ratio >= 1
                        ? destPos_1[key]
                        : pos + info_1.delta[key] * (easingPer - prevEasingPer_1);
                    // Subtract distance from distance already moved.
                    // Recalculate the remaining distance.
                    // Fix the bouncing phenomenon by changing the range.
                    var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);
                    if (nextPos !== circulatedPos) {
                        // circular
                        var rangeOffset = directions_1[key] * (options.range[1] - options.range[0]);
                        destPos_1[key] -= rangeOffset;
                        prevPos_1[key] -= rangeOffset;
                    }
                    return circulatedPos;
                });
                var isCanceled = !self_1.em.triggerChange(toPos, false, prevPos_1);
                prevPos_1 = toPos;
                prevTime_1 = currentTime;
                prevEasingPer_1 = easingPer;
                if (easingPer >= 1) {
                    destPos_1 = self_1.getFinalPos(destPos_1, originalIntendedPos_1);
                    if (!equal(destPos_1, self_1.axm.get(Object.keys(destPos_1)))) {
                        self_1.em.triggerChange(destPos_1, true, prevPos_1);
                    }
                    complete();
                    return;
                }
                else if (isCanceled) {
                    self_1.finish(false);
                }
                else {
                    // animationEnd
                    self_1._raf = requestAnimationFrame(loop);
                }
            })();
        }
        else {
            this.em.triggerChange(param.destPos, true);
            complete();
        }
    };
    /**
     * Get estimated final value.
     *
     * If destPos is within the 'error range' of the original intended position, the initial intended position is returned.
     *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;
     * If dest Pos is outside the 'range of error' compared to the originally intended pos, it is returned rounded based on the originally intended pos.
     *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123
     *
     * @param originalIntendedPos
     * @param destPos
     */
    AnimationManager.prototype.getFinalPos = function (destPos, originalIntendedPos) {
        var _this = this;
        // compare destPos and originalIntendedPos
        var ERROR_LIMIT = 0.000001;
        var finalPos = map(destPos, function (value, key) {
            if (value >= originalIntendedPos[key] - ERROR_LIMIT && value <= originalIntendedPos[key] + ERROR_LIMIT) {
                // In error range, return original intended
                return originalIntendedPos[key];
            }
            else {
                // Out of error range, return rounded pos.
                var roundUnit = _this.getRoundUnit(value, key);
                var result = roundNumber(value, roundUnit);
                return result;
            }
        });
        return finalPos;
    };
    AnimationManager.prototype.getRoundUnit = function (val, key) {
        var roundUnit = this.options.round; // manual mode
        var minRoundUnit = null; // auto mode
        // auto mode
        if (!roundUnit) {
            // Get minimum round unit
            var options = this.axm.getAxisOptions(key);
            minRoundUnit = inversePow(Math.max(getDecimalPlace(options.range[0]), getDecimalPlace(options.range[1]), getDecimalPlace(val)));
        }
        return minRoundUnit || roundUnit;
    };
    AnimationManager.prototype.getUserControll = function (param) {
        var userWish = param.setTo();
        userWish.destPos = this.axm.get(userWish.destPos);
        userWish.duration = minMax(userWish.duration, this.options.minimumDuration, this.options.maximumDuration);
        return userWish;
    };
    AnimationManager.prototype.animateTo = function (destPos, duration, option) {
        var _this = this;
        var param = this.createAnimationParam(destPos, duration, option);
        var depaPos = __assign({}, param.depaPos);
        var retTrigger = this.em.triggerAnimationStart(param);
        // to control
        var userWish = this.getUserControll(param);
        // You can't stop the 'animationStart' event when 'circular' is true.
        if (!retTrigger && this.axm.every(userWish.destPos, function (v, opt) { return isCircularable(v, opt.range, opt.circular); })) {
            console.warn("You can't stop the 'animation' event when 'circular' is true.");
        }
        if (retTrigger && !equal(userWish.destPos, depaPos)) {
            var inputEvent = option && option.event || null;
            this.animateLoop({
                depaPos: depaPos,
                destPos: userWish.destPos,
                duration: userWish.duration,
                delta: this.axm.getDelta(depaPos, userWish.destPos),
                isTrusted: !!inputEvent,
                inputEvent: inputEvent,
                input: option && option.input || null,
            }, function () { return _this.animationEnd(); });
        }
    };
    AnimationManager.prototype.easing = function (p) {
        return p > 1 ? 1 : this.options.easing(p);
    };
    AnimationManager.prototype.setTo = function (pos, duration) {
        if (duration === void 0) { duration = 0; }
        var axes = Object.keys(pos);
        this.grab(axes);
        var orgPos = this.axm.get(axes);
        if (equal(pos, orgPos)) {
            return this;
        }
        this.itm.setInterrupt(true);
        var movedPos = filter(pos, function (v, k) { return orgPos[k] !== v; });
        if (!Object.keys(movedPos).length) {
            return this;
        }
        movedPos = this.axm.map(movedPos, function (v, opt) {
            var range = opt.range, circular = opt.circular;
            if (circular && (circular[0] || circular[1])) {
                return v;
            }
            else {
                return getInsidePosition(v, range, circular);
            }
        });
        if (equal(movedPos, orgPos)) {
            return this;
        }
        if (duration > 0) {
            this.animateTo(movedPos, duration);
        }
        else {
            this.em.triggerChange(movedPos);
            this.finish(false);
        }
        return this;
    };
    AnimationManager.prototype.setBy = function (pos, duration) {
        if (duration === void 0) { duration = 0; }
        return this.setTo(map(this.axm.get(Object.keys(pos)), function (v, k) { return v + pos[k]; }), duration);
    };
    return AnimationManager;
}());
export { AnimationManager };
//# sourceMappingURL=AnimationManager.js.map