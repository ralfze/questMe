var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import Axes from "../Axes";
import { toAxis } from "./InputType";
import { PanInput } from "./PanInput";
/**
 * @class eg.Axes.RotatePanInput
 * @classdesc A module that passes the angle moved by touch to Axes and uses one axis of rotation.<br>[Details](https://github.com/naver/egjs-axes/wiki/RotatePanInput)
 * @ko 터치에 의해 움직인 각도를 Axes 에 전달하며 1개의 회전축만 사용한다.<br>[상세내용](https://github.com/naver/egjs-axes/wiki/RotatePanInput-%7C-%ED%95%9C%EA%B5%AD%EC%96%B4)
 *
 * @example
 * const input = new eg.Axes.RotatePanInput("#area");
 *
 * var axes = new eg.Axes({
 *	// property name('angle') could be anything you want (eg. x, y, z...)
 * 	angle: {
 * 		range: [-180, 180] // from -180deg to 180deg
 * 	}
 * });
 *
 * axes.connect("angle", input)
 *
 * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.RotatePanInput module <ko>eg.Axes.RotatePanInput 모듈을 사용할 엘리먼트</ko>
 * @param {PanInputOption} [options] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>
 * @extends eg.Axes.PanInput
 */
var RotatePanInput = /** @class */ (function (_super) {
    __extends(RotatePanInput, _super);
    function RotatePanInput(el, options) {
        var _this = _super.call(this, el, options) || this;
        _this.prevQuadrant = null;
        _this.lastDiff = 0;
        return _this;
    }
    RotatePanInput.prototype.mapAxes = function (axes) {
        this._direction = Axes.DIRECTION_ALL;
        this.axes = axes;
    };
    RotatePanInput.prototype.onHammerInput = function (event) {
        if (this.isEnable()) {
            if (event.isFirst) {
                this.observer.hold(this, event);
                this.onPanstart(event);
            }
            else if (event.isFinal) {
                this.onPanend(event);
            }
        }
    };
    RotatePanInput.prototype.onPanstart = function (event) {
        var rect = this.element.getBoundingClientRect();
        /**
         * Responsive
         */
        // TODO: how to do if element is ellipse not circle.
        this.coefficientForDistanceToAngle = 360 / (rect.width * Math.PI); // from 2*pi*r * x / 360
        // TODO: provide a way to set origin like https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
        this.rotateOrigin = [rect.left + (rect.width - 1) / 2, rect.top + (rect.height - 1) / 2];
        // init angle.
        this.prevAngle = null;
        this.triggerChange(event);
    };
    RotatePanInput.prototype.onPanmove = function (event) {
        this.triggerChange(event);
    };
    RotatePanInput.prototype.onPanend = function (event) {
        this.triggerChange(event);
        this.triggerAnimation(event);
    };
    RotatePanInput.prototype.triggerChange = function (event) {
        var angle = this.getAngle(event.center.x, event.center.y);
        var quadrant = this.getQuadrant(event.center.x, event.center.y);
        var diff = this.getDifference(this.prevAngle, angle, this.prevQuadrant, quadrant);
        this.prevAngle = angle;
        this.prevQuadrant = quadrant;
        if (diff === 0) {
            return;
        }
        this.lastDiff = diff;
        this.observer.change(this, event, toAxis(this.axes, [-diff])); // minus for clockwise
    };
    RotatePanInput.prototype.triggerAnimation = function (event) {
        var vx = event.velocityX;
        var vy = event.velocityY;
        var velocity = Math.sqrt(vx * vx + vy * vy) * (this.lastDiff > 0 ? -1 : 1); // clockwise
        var duration = Math.abs(velocity / -this.observer.options.deceleration);
        var distance = velocity / 2 * duration;
        this.observer.release(this, event, toAxis(this.axes, [distance * this.coefficientForDistanceToAngle]));
    };
    RotatePanInput.prototype.getDifference = function (prevAngle, angle, prevQuadrant, quadrant) {
        var diff;
        if (prevAngle === null) {
            diff = 0;
        }
        else if (prevQuadrant === 1 && quadrant === 4) {
            diff = -prevAngle - (360 - angle);
        }
        else if (prevQuadrant === 4 && quadrant === 1) {
            diff = (360 - prevAngle) + angle;
        }
        else {
            diff = angle - prevAngle;
        }
        return diff;
    };
    RotatePanInput.prototype.getPosFromOrigin = function (posX, posY) {
        return {
            x: posX - this.rotateOrigin[0],
            y: this.rotateOrigin[1] - posY,
        };
    };
    RotatePanInput.prototype.getAngle = function (posX, posY) {
        var _a = this.getPosFromOrigin(posX, posY), x = _a.x, y = _a.y;
        var angle = Math.atan2(y, x) * 180 / Math.PI;
        // console.log(angle, x, y);
        return angle < 0 ? 360 + angle : angle;
    };
    /**
     * Quadrant
     *       y(+)
     *       |
     *   2   |    1
     * --------------->x(+)
     *   3   |    4
     *       |
     */
    RotatePanInput.prototype.getQuadrant = function (posX, posY) {
        var _a = this.getPosFromOrigin(posX, posY), x = _a.x, y = _a.y;
        var q = 0;
        if (x >= 0 && y >= 0) {
            q = 1;
        }
        else if (x < 0 && y >= 0) {
            q = 2;
        }
        else if (x < 0 && y < 0) {
            q = 3;
        }
        else if (x >= 0 && y < 0) {
            q = 4;
        }
        return q;
    };
    return RotatePanInput;
}(PanInput));
export { RotatePanInput };
//# sourceMappingURL=RotatePanInput.js.map