import VanillaFlicking__default, { EVENTS, withFlickingMethods, ExternalRenderer, getFlickingAttached, getDefaultCameraTransform, VirtualRenderingStrategy, NormalRenderingStrategy, ExternalPanel, sync, range, CLASS } from '@egjs/flicking';
export * from '@egjs/flicking';
import { Directive, ElementRef, Renderer2, EventEmitter, Component, ViewEncapsulation, Inject, PLATFORM_ID, Input, Output, HostBinding, ContentChildren, NgModule } from '@angular/core';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import ListDiffer from '@egjs/list-differ';
import { __decorate, __metadata, __awaiter } from 'tslib';

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
class NgxFlickingPanel {
    constructor(_elementref, _renderer) {
        this._elementref = _elementref;
        this._renderer = _renderer;
        this._rendered = true;
    }
    get nativeElement() { return this._elementref.nativeElement; }
    get rendered() { return this._rendered; }
    show(flicking) {
        this._rendered = true;
        const el = this.nativeElement;
        const cameraEl = flicking.camera.element;
        if (el.parentElement !== cameraEl) {
            this._renderer.appendChild(cameraEl, el);
        }
    }
    hide(flicking) {
        this._rendered = false;
        const el = this.nativeElement;
        const cameraEl = flicking.camera.element;
        if (el.parentElement === cameraEl) {
            this._renderer.removeChild(cameraEl, el);
        }
    }
}
NgxFlickingPanel.decorators = [
    { type: Directive, args: [{
                selector: "[flicking-panel], [FlickingPanel]"
            },] }
];
NgxFlickingPanel.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];

const ɵ0 = (key) => EVENTS[key];
const EVENT_NAMES = Object.keys(EVENTS).map(ɵ0);

class FlickingInterface {
}
__decorate([
    withFlickingMethods,
    __metadata("design:type", VanillaFlicking__default)
], FlickingInterface.prototype, "_vanillaFlicking", void 0);

class NgxRenderer extends ExternalRenderer {
    constructor(options) {
        super(options);
        this._ngxFlicking = options.ngxFlicking;
        this._ngxRenderer = options.ngxRenderer;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    render() {
        return __awaiter(this, void 0, void 0, function* () {
            const flicking = getFlickingAttached(this._flicking);
            const strategy = this._strategy;
            strategy.updateRenderingPanels(flicking);
            strategy.renderPanels(flicking);
            this._resetPanelElementOrder();
        });
    }
    _collectPanels() {
        const flicking = getFlickingAttached(this._flicking);
        const children = this._ngxFlicking.ngxPanels.toArray();
        this._panels = this._strategy.collectPanels(flicking, children);
    }
    _createPanel(externalComponent, options) {
        return this._strategy.createPanel(externalComponent, options);
    }
    _resetPanelElementOrder() {
        const flicking = getFlickingAttached(this._flicking);
        const renderer = this._ngxRenderer;
        const cameraEl = flicking.camera.element;
        // We're using reversed panels here as last panel should be the last element of camera element
        const reversedElements = this._strategy
            .getRenderingElementsByOrder(flicking)
            .reverse();
        reversedElements.forEach((el, idx) => {
            const nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;
            if (el.nextElementSibling !== nextEl) {
                renderer.insertBefore(cameraEl, el, nextEl);
            }
        });
    }
}

class NgxElementProvider {
    constructor(el) {
        this._el = el;
    }
    get element() { return this._el.nativeElement; }
    get rendered() { return this._el.rendered; }
    show(flicking) {
        this._el.show(flicking);
    }
    hide(flicking) {
        this._el.hide(flicking);
    }
}

/**
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
class NgxFlickingComponent extends FlickingInterface {
    constructor(elRef, renderer, platformId) {
        super();
        this.options = {};
        this.plugins = [];
        this.hideBeforeInit = false;
        this._pluginsDiffer = new ListDiffer();
        this._elementDiffer = null;
        this._elRef = elRef;
        this._ngxRenderer = renderer;
        this._platformId = platformId;
        this._vanillaFlicking = null;
        EVENT_NAMES.forEach(evtName => {
            this[evtName] = new EventEmitter();
        });
    }
    get isVertical() {
        return this.options.horizontal === false;
    }
    get isHiddenBeforeInit() {
        const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;
        return this.hideBeforeInit && !initialized;
    }
    get cameraStyleBeforeInit() {
        const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;
        return !initialized && this.firstPanelSize
            ? { transform: getDefaultCameraTransform(this.options.align, this.options.horizontal, this.firstPanelSize) }
            : {};
    }
    get ngxPanels() { return this._ngxPanels; }
    ngAfterViewInit() {
        if (!isPlatformBrowser(this._platformId))
            return;
        const options = this.options;
        const viewportEl = this._elRef.nativeElement;
        const virtual = options.virtual && options.panelsPerView > 0;
        const rendererOptions = {
            ngxFlicking: this,
            ngxRenderer: this._ngxRenderer,
            strategy: virtual
                ? new VirtualRenderingStrategy()
                : new NormalRenderingStrategy({
                    providerCtor: NgxElementProvider,
                    panelCtor: ExternalPanel
                })
        };
        if (virtual) {
            this._initVirtualElements();
        }
        // This prevents mousemove to call ngDoCheck & noAfterContentChecked everytime
        const flicking = new VanillaFlicking__default(viewportEl, Object.assign(Object.assign({}, this.options), { renderExternal: {
                renderer: NgxRenderer,
                rendererOptions
            } }));
        this._vanillaFlicking = flicking;
        const elementDiffer = new ListDiffer(this._ngxPanels.toArray());
        this._elementDiffer = elementDiffer;
        this._bindEvents();
        this._checkPlugins();
        if (this.status) {
            flicking.setStatus(this.status);
        }
        this._ngxPanels.changes.subscribe(() => {
            const panels = this._ngxPanels.toArray();
            const diffResult = elementDiffer.update(panels);
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            sync(flicking, diffResult, [...diffResult.maintained.map(([_, idx]) => diffResult.list[idx]), ...diffResult.added.map(idx => diffResult.list[idx])]);
        });
    }
    ngOnDestroy() {
        if (!this._vanillaFlicking)
            return;
        this._vanillaFlicking.destroy();
    }
    ngOnChanges() {
        const flicking = this._vanillaFlicking;
        if (!flicking)
            return;
        void flicking.renderer.forceRenderAllPanels();
        this._checkPlugins();
    }
    _bindEvents() {
        const flicking = this._vanillaFlicking;
        EVENT_NAMES.forEach(evtName => {
            flicking.on(evtName, e => {
                // Style guide: Event - https://angular.io/guide/styleguide#dont-prefix-output-properties
                const emitter = this[evtName];
                e.currentTarget = this;
                if (emitter) {
                    emitter.emit(e);
                }
            });
        });
    }
    _checkPlugins() {
        const flicking = this._vanillaFlicking;
        if (!flicking)
            return;
        const { list, added, removed, prevList } = this._pluginsDiffer.update(this.plugins);
        flicking.addPlugins(...added.map(index => list[index]));
        flicking.removePlugins(...removed.map(index => prevList[index]));
    }
    _initVirtualElements() {
        const options = this.options;
        const renderer = this._ngxRenderer;
        const cameraElement = this._elRef.nativeElement.firstElementChild;
        const panelsPerView = options.panelsPerView;
        const virtual = options.virtual;
        const fragment = document.createDocumentFragment();
        const newElements = range(panelsPerView + 1).map(idx => {
            var _a;
            const panelEl = renderer.createElement("div");
            panelEl.className = (_a = virtual.panelClass) !== null && _a !== void 0 ? _a : CLASS.DEFAULT_VIRTUAL;
            panelEl.dataset.elementIndex = idx.toString();
            return panelEl;
        });
        newElements.forEach(el => {
            fragment.appendChild(el);
        });
        renderer.appendChild(cameraElement, fragment);
    }
}
NgxFlickingComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-flicking, [NgxFlicking]",
                template: `
    <div class="flicking-camera" [ngStyle]="cameraStyleBeforeInit">
      <ng-content></ng-content>
    </div>
    <ng-content select="[in-viewport]"></ng-content>`,
                host: {
                    class: "flicking-viewport",
                    style: "display: block;"
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".flicking-viewport{overflow:hidden;position:relative}.flicking-camera{-ms-flex-direction:row;-webkit-box-direction:normal;-webkit-box-orient:horizontal;display:-webkit-box;display:-ms-flexbox;display:flex;flex-direction:row;height:100%;position:relative;width:100%;z-index:1}.flicking-camera>*{-ms-flex-negative:0;flex-shrink:0}.flicking-viewport.vertical,.flicking-viewport.vertical>.flicking-camera{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.flicking-viewport.vertical>.flicking-camera{-ms-flex-direction:column;-webkit-box-direction:normal;-webkit-box-orient:vertical;flex-direction:column}.flicking-viewport.flicking-hidden .flicking-camera>*{visibility:hidden}\n/*# sourceMappingURL=flicking.css.map */"]
            },] }
];
NgxFlickingComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgxFlickingComponent.propDecorators = {
    options: [{ type: Input }],
    plugins: [{ type: Input }],
    status: [{ type: Input }],
    hideBeforeInit: [{ type: Input }],
    firstPanelSize: [{ type: Input }],
    ready: [{ type: Output }],
    beforeResize: [{ type: Output }],
    afterResize: [{ type: Output }],
    holdStart: [{ type: Output }],
    holdEnd: [{ type: Output }],
    moveStart: [{ type: Output }],
    move: [{ type: Output }],
    moveEnd: [{ type: Output }],
    willChange: [{ type: Output }],
    changed: [{ type: Output }],
    willRestore: [{ type: Output }],
    restored: [{ type: Output }],
    select: [{ type: Output }],
    needPanel: [{ type: Output }],
    visibleChange: [{ type: Output }],
    reachEdge: [{ type: Output }],
    panelChange: [{ type: Output }],
    isVertical: [{ type: HostBinding, args: ["class.vertical",] }],
    isHiddenBeforeInit: [{ type: HostBinding, args: ["class.flicking-hidden",] }],
    _ngxPanels: [{ type: ContentChildren, args: [NgxFlickingPanel,] }]
};

class NgxFlickingModule {
}
NgxFlickingModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxFlickingComponent, NgxFlickingPanel],
                imports: [CommonModule],
                exports: [NgxFlickingComponent, NgxFlickingPanel]
            },] }
];

/*
 * Public API Surface of ngx-flicking
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxFlickingComponent, NgxFlickingModule, NgxFlickingPanel };
//# sourceMappingURL=egjs-ngx-flicking.js.map
