import VanillaFlicking__default, { EVENTS, withFlickingMethods, ExternalRenderer, getFlickingAttached, getDefaultCameraTransform, VirtualRenderingStrategy, NormalRenderingStrategy, ExternalPanel, sync, range, CLASS } from '@egjs/flicking';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["*", [["", "in-viewport", ""]]];
const _c1 = ["*", "[in-viewport]"];
export * from '@egjs/flicking';
import { Directive, ElementRef, Renderer2, EventEmitter, Component, ViewEncapsulation, Inject, PLATFORM_ID, Input, Output, HostBinding, ContentChildren, NgModule } from '@angular/core';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import ListDiffer from '@egjs/list-differ';
import { __decorate, __metadata, __awaiter } from 'tslib';

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
class NgxFlickingPanel {
    constructor(_elementref, _renderer) {
        this._elementref = _elementref;
        this._renderer = _renderer;
        this._rendered = true;
    }
    get nativeElement() { return this._elementref.nativeElement; }
    get rendered() { return this._rendered; }
    show(flicking) {
        this._rendered = true;
        const el = this.nativeElement;
        const cameraEl = flicking.camera.element;
        if (el.parentElement !== cameraEl) {
            this._renderer.appendChild(cameraEl, el);
        }
    }
    hide(flicking) {
        this._rendered = false;
        const el = this.nativeElement;
        const cameraEl = flicking.camera.element;
        if (el.parentElement === cameraEl) {
            this._renderer.removeChild(cameraEl, el);
        }
    }
}
NgxFlickingPanel.ɵfac = function NgxFlickingPanel_Factory(t) { return new (t || NgxFlickingPanel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxFlickingPanel.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxFlickingPanel, selectors: [["", "flicking-panel", ""], ["", "FlickingPanel", ""]] });
NgxFlickingPanel.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];

const ɵ0 = (key) => EVENTS[key];
const EVENT_NAMES = Object.keys(EVENTS).map(ɵ0);

class FlickingInterface {
}
__decorate([
    withFlickingMethods,
    __metadata("design:type", VanillaFlicking__default)
], FlickingInterface.prototype, "_vanillaFlicking", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxFlickingPanel, [{
        type: Directive,
        args: [{
                selector: "[flicking-panel], [FlickingPanel]"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, null); })();

class NgxRenderer extends ExternalRenderer {
    constructor(options) {
        super(options);
        this._ngxFlicking = options.ngxFlicking;
        this._ngxRenderer = options.ngxRenderer;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    render() {
        return __awaiter(this, void 0, void 0, function* () {
            const flicking = getFlickingAttached(this._flicking);
            const strategy = this._strategy;
            strategy.updateRenderingPanels(flicking);
            strategy.renderPanels(flicking);
            this._resetPanelElementOrder();
        });
    }
    _collectPanels() {
        const flicking = getFlickingAttached(this._flicking);
        const children = this._ngxFlicking.ngxPanels.toArray();
        this._panels = this._strategy.collectPanels(flicking, children);
    }
    _createPanel(externalComponent, options) {
        return this._strategy.createPanel(externalComponent, options);
    }
    _resetPanelElementOrder() {
        const flicking = getFlickingAttached(this._flicking);
        const renderer = this._ngxRenderer;
        const cameraEl = flicking.camera.element;
        // We're using reversed panels here as last panel should be the last element of camera element
        const reversedElements = this._strategy
            .getRenderingElementsByOrder(flicking)
            .reverse();
        reversedElements.forEach((el, idx) => {
            const nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;
            if (el.nextElementSibling !== nextEl) {
                renderer.insertBefore(cameraEl, el, nextEl);
            }
        });
    }
}

class NgxElementProvider {
    constructor(el) {
        this._el = el;
    }
    get element() { return this._el.nativeElement; }
    get rendered() { return this._el.rendered; }
    show(flicking) {
        this._el.show(flicking);
    }
    hide(flicking) {
        this._el.hide(flicking);
    }
}

/**
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
class NgxFlickingComponent extends FlickingInterface {
    constructor(elRef, renderer, platformId) {
        super();
        this.options = {};
        this.plugins = [];
        this.hideBeforeInit = false;
        this._pluginsDiffer = new ListDiffer();
        this._elementDiffer = null;
        this._elRef = elRef;
        this._ngxRenderer = renderer;
        this._platformId = platformId;
        this._vanillaFlicking = null;
        EVENT_NAMES.forEach(evtName => {
            this[evtName] = new EventEmitter();
        });
    }
    get isVertical() {
        return this.options.horizontal === false;
    }
    get isHiddenBeforeInit() {
        const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;
        return this.hideBeforeInit && !initialized;
    }
    get cameraStyleBeforeInit() {
        const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;
        return !initialized && this.firstPanelSize
            ? { transform: getDefaultCameraTransform(this.options.align, this.options.horizontal, this.firstPanelSize) }
            : {};
    }
    get ngxPanels() { return this._ngxPanels; }
    ngAfterViewInit() {
        if (!isPlatformBrowser(this._platformId))
            return;
        const options = this.options;
        const viewportEl = this._elRef.nativeElement;
        const virtual = options.virtual && options.panelsPerView > 0;
        const rendererOptions = {
            ngxFlicking: this,
            ngxRenderer: this._ngxRenderer,
            strategy: virtual
                ? new VirtualRenderingStrategy()
                : new NormalRenderingStrategy({
                    providerCtor: NgxElementProvider,
                    panelCtor: ExternalPanel
                })
        };
        if (virtual) {
            this._initVirtualElements();
        }
        // This prevents mousemove to call ngDoCheck & noAfterContentChecked everytime
        const flicking = new VanillaFlicking__default(viewportEl, Object.assign(Object.assign({}, this.options), { renderExternal: {
                renderer: NgxRenderer,
                rendererOptions
            } }));
        this._vanillaFlicking = flicking;
        const elementDiffer = new ListDiffer(this._ngxPanels.toArray());
        this._elementDiffer = elementDiffer;
        this._bindEvents();
        this._checkPlugins();
        if (this.status) {
            flicking.setStatus(this.status);
        }
        this._ngxPanels.changes.subscribe(() => {
            const panels = this._ngxPanels.toArray();
            const diffResult = elementDiffer.update(panels);
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            sync(flicking, diffResult, [...diffResult.maintained.map(([_, idx]) => diffResult.list[idx]), ...diffResult.added.map(idx => diffResult.list[idx])]);
        });
    }
    ngOnDestroy() {
        if (!this._vanillaFlicking)
            return;
        this._vanillaFlicking.destroy();
    }
    ngOnChanges() {
        const flicking = this._vanillaFlicking;
        if (!flicking)
            return;
        void flicking.renderer.forceRenderAllPanels();
        this._checkPlugins();
    }
    _bindEvents() {
        const flicking = this._vanillaFlicking;
        EVENT_NAMES.forEach(evtName => {
            flicking.on(evtName, e => {
                // Style guide: Event - https://angular.io/guide/styleguide#dont-prefix-output-properties
                const emitter = this[evtName];
                e.currentTarget = this;
                if (emitter) {
                    emitter.emit(e);
                }
            });
        });
    }
    _checkPlugins() {
        const flicking = this._vanillaFlicking;
        if (!flicking)
            return;
        const { list, added, removed, prevList } = this._pluginsDiffer.update(this.plugins);
        flicking.addPlugins(...added.map(index => list[index]));
        flicking.removePlugins(...removed.map(index => prevList[index]));
    }
    _initVirtualElements() {
        const options = this.options;
        const renderer = this._ngxRenderer;
        const cameraElement = this._elRef.nativeElement.firstElementChild;
        const panelsPerView = options.panelsPerView;
        const virtual = options.virtual;
        const fragment = document.createDocumentFragment();
        const newElements = range(panelsPerView + 1).map(idx => {
            var _a;
            const panelEl = renderer.createElement("div");
            panelEl.className = (_a = virtual.panelClass) !== null && _a !== void 0 ? _a : CLASS.DEFAULT_VIRTUAL;
            panelEl.dataset.elementIndex = idx.toString();
            return panelEl;
        });
        newElements.forEach(el => {
            fragment.appendChild(el);
        });
        renderer.appendChild(cameraElement, fragment);
    }
}
NgxFlickingComponent.ɵfac = function NgxFlickingComponent_Factory(t) { return new (t || NgxFlickingComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
NgxFlickingComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxFlickingComponent, selectors: [["ngx-flicking"], ["", "NgxFlicking", ""]], contentQueries: function NgxFlickingComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxFlickingPanel, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._ngxPanels = _t);
    } }, hostAttrs: [1, "flicking-viewport", 2, "display", "block"], hostVars: 4, hostBindings: function NgxFlickingComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("vertical", ctx.isVertical)("flicking-hidden", ctx.isHiddenBeforeInit);
    } }, inputs: { options: "options", plugins: "plugins", hideBeforeInit: "hideBeforeInit", status: "status", firstPanelSize: "firstPanelSize" }, outputs: { ready: "ready", beforeResize: "beforeResize", afterResize: "afterResize", holdStart: "holdStart", holdEnd: "holdEnd", moveStart: "moveStart", move: "move", moveEnd: "moveEnd", willChange: "willChange", changed: "changed", willRestore: "willRestore", restored: "restored", select: "select", needPanel: "needPanel", visibleChange: "visibleChange", reachEdge: "reachEdge", panelChange: "panelChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 3, vars: 1, consts: [[1, "flicking-camera", 3, "ngStyle"]], template: function NgxFlickingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ctx.cameraStyleBeforeInit);
    } }, directives: [ɵngcc1.NgStyle], styles: [".flicking-viewport{overflow:hidden;position:relative}.flicking-camera{-ms-flex-direction:row;-webkit-box-direction:normal;-webkit-box-orient:horizontal;display:-webkit-box;display:-ms-flexbox;display:flex;flex-direction:row;height:100%;position:relative;width:100%;z-index:1}.flicking-camera>*{-ms-flex-negative:0;flex-shrink:0}.flicking-viewport.vertical,.flicking-viewport.vertical>.flicking-camera{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.flicking-viewport.vertical>.flicking-camera{-ms-flex-direction:column;-webkit-box-direction:normal;-webkit-box-orient:vertical;flex-direction:column}.flicking-viewport.flicking-hidden .flicking-camera>*{visibility:hidden}\n/*# sourceMappingURL=flicking.css.map */"], encapsulation: 2 });
NgxFlickingComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgxFlickingComponent.propDecorators = {
    options: [{ type: Input }],
    plugins: [{ type: Input }],
    status: [{ type: Input }],
    hideBeforeInit: [{ type: Input }],
    firstPanelSize: [{ type: Input }],
    ready: [{ type: Output }],
    beforeResize: [{ type: Output }],
    afterResize: [{ type: Output }],
    holdStart: [{ type: Output }],
    holdEnd: [{ type: Output }],
    moveStart: [{ type: Output }],
    move: [{ type: Output }],
    moveEnd: [{ type: Output }],
    willChange: [{ type: Output }],
    changed: [{ type: Output }],
    willRestore: [{ type: Output }],
    restored: [{ type: Output }],
    select: [{ type: Output }],
    needPanel: [{ type: Output }],
    visibleChange: [{ type: Output }],
    reachEdge: [{ type: Output }],
    panelChange: [{ type: Output }],
    isVertical: [{ type: HostBinding, args: ["class.vertical",] }],
    isHiddenBeforeInit: [{ type: HostBinding, args: ["class.flicking-hidden",] }],
    _ngxPanels: [{ type: ContentChildren, args: [NgxFlickingPanel,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxFlickingComponent, [{
        type: Component,
        args: [{
                selector: "ngx-flicking, [NgxFlicking]",
                template: `
    <div class="flicking-camera" [ngStyle]="cameraStyleBeforeInit">
      <ng-content></ng-content>
    </div>
    <ng-content select="[in-viewport]"></ng-content>`,
                host: {
                    class: "flicking-viewport",
                    style: "display: block;"
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".flicking-viewport{overflow:hidden;position:relative}.flicking-camera{-ms-flex-direction:row;-webkit-box-direction:normal;-webkit-box-orient:horizontal;display:-webkit-box;display:-ms-flexbox;display:flex;flex-direction:row;height:100%;position:relative;width:100%;z-index:1}.flicking-camera>*{-ms-flex-negative:0;flex-shrink:0}.flicking-viewport.vertical,.flicking-viewport.vertical>.flicking-camera{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.flicking-viewport.vertical>.flicking-camera{-ms-flex-direction:column;-webkit-box-direction:normal;-webkit-box-orient:vertical;flex-direction:column}.flicking-viewport.flicking-hidden .flicking-camera>*{visibility:hidden}\n/*# sourceMappingURL=flicking.css.map */"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { options: [{
            type: Input
        }], plugins: [{
            type: Input
        }], hideBeforeInit: [{
            type: Input
        }], isVertical: [{
            type: HostBinding,
            args: ["class.vertical"]
        }], isHiddenBeforeInit: [{
            type: HostBinding,
            args: ["class.flicking-hidden"]
        }], status: [{
            type: Input
        }], firstPanelSize: [{
            type: Input
        }], ready: [{
            type: Output
        }], beforeResize: [{
            type: Output
        }], afterResize: [{
            type: Output
        }], holdStart: [{
            type: Output
        }], holdEnd: [{
            type: Output
        }], moveStart: [{
            type: Output
        }], move: [{
            type: Output
        }], moveEnd: [{
            type: Output
        }], willChange: [{
            type: Output
        }], changed: [{
            type: Output
        }], willRestore: [{
            type: Output
        }], restored: [{
            type: Output
        }], select: [{
            type: Output
        }], needPanel: [{
            type: Output
        }], visibleChange: [{
            type: Output
        }], reachEdge: [{
            type: Output
        }], panelChange: [{
            type: Output
        }], _ngxPanels: [{
            type: ContentChildren,
            args: [NgxFlickingPanel]
        }] }); })();

class NgxFlickingModule {
}
NgxFlickingModule.ɵfac = function NgxFlickingModule_Factory(t) { return new (t || NgxFlickingModule)(); };
NgxFlickingModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxFlickingModule });
NgxFlickingModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxFlickingModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxFlickingComponent, NgxFlickingPanel],
                imports: [CommonModule],
                exports: [NgxFlickingComponent, NgxFlickingPanel]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxFlickingModule, { declarations: function () { return [NgxFlickingComponent, NgxFlickingPanel]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgxFlickingComponent, NgxFlickingPanel]; } }); })();

/*
 * Public API Surface of ngx-flicking
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxFlickingComponent, NgxFlickingModule, NgxFlickingPanel };

//# sourceMappingURL=egjs-ngx-flicking.js.map